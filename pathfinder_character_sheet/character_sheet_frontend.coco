from enum import Enum
from random import Random

import justpy as jp
from pathfinder_character_sheet.character_sheet_parser import *
from pathfinder_character_sheet.character import *
from pathfinder_character_sheet.utils import *

# Fix vision
# Conditional modifiers
# HP text box
# Spell counters (checkboxes)
# Add ranged attack button
# Long rest button
# Make look not bad
# Readme

def make_roll_button(rng, roll_modal, text="", modifier=0, die=20, num_dice=1):
    button = jp.Button(
        text=text,
        classes="bg-blue-500 text-white rounded px-4 py-2",
        click=toggle_roll_modal$(rng=rng, modifier=modifier, die=die, num_dice=num_dice)
    )
    button.roll_modal = roll_modal
    return button

def make_table(headers):
    table = jp.Table(classes="min-w-full bg-white border rounded shadow")

    table_header = jp.Thead(classes="bg-gray-300")
    table.add(table_header)
    header_row = jp.Tr()
    table_header.add(header_row)

    for header in headers:
        th = jp.Th(classes="text-left py-2 px-3", text=header)
        header_row.add(th)

    # Table body
    table_body = jp.Tbody()
    table.add(table_body)

    return table, table_body

def make_cell_style_class():
    return "border-t py-2 px-3"

def make_button_div():
    return jp.Td(classes=make_cell_style_class())

def make_cell_div(text):
    return jp.Td(classes=make_cell_style_class(), inner_html=text)

def make_row_flex_div():
    return jp.Div(classes="flex w-full p-4 m-4", style="background-color: #f9f9f9;")

def make_col_flex_div(overflow=False):
    classes = "flex-col w-full p-4 m-4"
    if overflow:
        classes += " overflow-auto overflow-x-auto"
    return jp.Div(classes=classes, style="background-color: #f9f9f9;")

def make_one_third_col_div():
    return jp.Div(classes="flex flex-col w-1/3 gap-4")

def make_title_box(height: str, width: str, title: str):
    box_style = f"background-color: #f9f9f9; border: 1px solid #ccc; shadow-lg; padding: 20px; w-{width}; height: {height}; overflow-y: auto rounded"
    box = jp.Div(classes="border border-gray-300 shadow-lg p-4 rounded-md m-4 flex items-center justify-center", style=box_style)
    title = jp.H2(classes="font-bold mb-2 text-center justify-center", text=title)
    box.add(title)
    return box

def make_title_row(char):
    title_row = make_row_flex_div()
    name_box = make_title_box("50px", "1/8", char.name)
    class_str = f"{', '.join(char.char_classes)}"
    if char.archetypes:
        class_str += ": " + ", ".join(char.archetypes)
    class_box = make_title_box("50px", "1/4", class_str)
    level_box = make_title_box("50px", "1/8", "Level " + str(char.level))
    title_row.add(name_box, class_box, level_box)
    return title_row

def make_ac_cell(char):
    ac_cell = make_col_flex_div()
    table, table_body = make_table([])
    ac_cell.add(table)

    total_data = make_cell_div(text=f"Total: {char.ac.total}")
    touch_data = make_cell_div(text=f"Touch: {char.ac.touch}")
    flat_data = make_cell_div(text=f"Flat: {char.ac.flat}")

    table_row = jp.Tr()
    table_row.add(total_data, touch_data, flat_data)

    table_body.add(table_row)

    return ac_cell

def make_useful_info_row(upper_container, char, rng):
    useful_info_row = make_col_flex_div()

    headers = ["Hit Points", "Initiative", "Armor Class"]
    if char.immunities:
        headers.append("Immunities")
    if char.resistances:
        headers.append("Resistances")
    if char.damage_reduction:
        headers.append("Dmg Reduction")
    table, table_body = make_table(headers)
    useful_info_row.add(table)

    hit_points_data = make_cell_div(text=char.max_hp)
    initiative_data = make_button_div()
    roll_modal = make_roll_modal(upper_container, modifier=[char.initiative], rng=rng)
    roll_button = make_roll_button(rng, roll_modal, text=make_mod_text([char.initiative]), modifier=[char.initiative])
    initiative_data.add(roll_button)
    ac_data = make_ac_cell(char)

    table_row = jp.Tr()
    table_body.add(table_row)

    table_row.add(hit_points_data, initiative_data, ac_data)
    if char.immunities:
        immunity_data = make_cell_div(text="<br>".join(char.immunities))
        table_row.add(immunity_data)
    if char.resistances:
        resistance_data = make_cell_div(text="<br>".join(char.resistances))
        table_row.add(resistance_data)
    if char.damage_reduction:
        reduction_data = make_cell_div(text="<br>".join(char.damage_reduction))
        table_row.add(reduction_data)
    return useful_info_row

def make_abilities_box(upper_container, char, rng):
    ability_row = make_col_flex_div()

    table, table_body = make_table(["Ability", "Score", "Modifier"])
    ability_row.add(table)

    for ability in Stats:
        table_row = jp.Tr()
        table_body.add(table_row)
        ability_name = make_button_div()
        table_row.add(ability_name)
        roll_modal = make_roll_modal(upper_container, modifier=[get_stat_modifier(char.stats[ability.value])], rng=rng)
        button = make_roll_button(rng, roll_modal, text=ability.name, modifier=[get_stat_modifier(char.stats[ability.value])])
        ability_name.add(button)
        score = make_cell_div(text=str(char.stats[ability.value]))
        table_row.add(score)
        modifier = make_cell_div(text=make_mod_text([get_stat_modifier(char.stats[ability.value])]))
        table_row.add(modifier)
    return ability_row

def make_weapons_box(upper_container, char, rng) -> dict[str, ((int; ...); str; str)]:
    weapons_row = make_col_flex_div()

    table, table_body = make_table(["Weapon", "Attack Bonus", "Damage", "Crit Multiplier"])
    weapons_row.add(table)

    for weapon, (attack_bonus, damage, multiplier) in char.weapons.items():
        table_row = jp.Tr()
        table_body.add(table_row)
        weapon_name = make_button_div()
        table_row.add(weapon_name)
        num_dice, die, modifier = get_attack_info(damage)
        attack_roll_modal = make_roll_modal(upper_container, modifier=[*attack_bonus], rng=rng)
        attack_button = make_roll_button(rng, attack_roll_modal, text=weapon, modifier=[*attack_bonus])
        weapon_name.add(attack_button)
        attack_bonus_cell = make_cell_div(text=make_mod_text(attack_bonus))
        table_row.add(attack_bonus_cell)
        damage_cell = make_button_div()
        table_row.add(damage_cell)
        damage_roll_modal = make_roll_modal(upper_container, modifier=[int(modifier)], die=int(die), num_dice=int(num_dice), rng=rng)
        damage_button = make_roll_button(
            rng, damage_roll_modal, text=damage, modifier=[int(modifier)], die=int(die), num_dice=int(num_dice))
        damage_cell.add(damage_button)
        multiplier_cell = make_cell_div(text=multiplier)
        table_row.add(multiplier_cell)

    return weapons_row

def make_ranged_weapons_box(upper_container, char, rng):
    weapons_row = make_col_flex_div(overflow=True)
    for weapon_name, weapon_info in char.ranged_weapons.items():
        headers = [weapon_name]
        attack_bonus = [""]
        damage = [""]
        crit = [""]

        for distance, (curr_attack_bonus, curr_damage, curr_crit) in weapon_info.items():
            headers.append(distance)
            attack_bonus.append(curr_attack_bonus)
            damage.append(curr_damage)
            crit.append(curr_crit)

        table, table_body = make_table(headers)
        weapons_row.add(table)
        attack_bonus_row = jp.Tr()
        damage_row = jp.Tr()
        table_body.add(attack_bonus_row, damage_row)

        for i in range(len(headers)):
            attack_bonus_cell = make_cell_div(text=make_mod_text(attack_bonus[i]))
            attack_bonus_row.add(attack_bonus_cell)
            damage_cell = make_button_div()
            damage_row.add(damage_cell)
            if damage[i]:
                num_dice, die_type, modifier = get_attack_info(damage[i])
                print(f'{modifier=}, {die_type=}, {num_dice=}')
                damage_roll_modal = make_roll_modal(upper_container, modifier=[int(modifier)], die=int(die_type), num_dice=int(num_dice), rng=rng)
                damage_button = make_roll_button(
                    rng, damage_roll_modal, text=damage[i], modifier=[int(modifier)], die=int(die_type), num_dice=int(num_dice))
                damage_cell.add(damage_button)

    return weapons_row

def make_special_attacks_box(char):
    attacks_row = make_col_flex_div()

    table, table_body = make_table(["Special Attacks"])
    attacks_row.add(table)

    for attack in char.special_attacks:
        table_row = jp.Tr()
        table_body.add(table_row)
        attack_cell = make_button_div()
        attack_cell.add(make_collapsible_comp(attack_cell, attack.name, attack.description))
        table_row.add(attack_cell)
    return attacks_row

def make_special_qualities_box(char):
    qualities_row = make_col_flex_div()

    table, table_body = make_table(["Special Qualities"])
    qualities_row.add(table)

    for quality in char.special_abilities:
        table_row = jp.Tr()
        table_body.add(table_row)
        quality_cell = make_button_div()
        quality_cell.add(make_collapsible_comp(quality_cell, quality.name, quality.description))
        table_row.add(quality_cell)
    return qualities_row

def make_saves_box(upper_container, char, rng):
    save_row = make_col_flex_div()

    table, table_body = make_table(["Saving Throws", "Total"])
    save_row.add(table)

    for throw in SavingThrows:
        table_row = jp.Tr()
        table_body.add(table_row)
        throw_name = make_button_div()
        table_row.add(throw_name)
        roll_modal = make_roll_modal(upper_container, modifier=[char.saving_throws[throw.value]], rng=rng)
        button = make_roll_button(rng, roll_modal, text=throw.name, modifier=[char.saving_throws[throw.value]])
        throw_name.add(button)
        total = make_cell_div(text=make_mod_text([char.saving_throws[throw.value]]))
        table_row.add(total)
    return save_row

def make_lang_box(char):
    lang_row = make_col_flex_div()

    table, table_body = make_table(["Languages"])
    lang_row.add(table)

    for lang in char.languages:
        table_row = jp.Tr()
        table_body.add(table_row)
        if lang == "Xenophobic":
            lang = "Glorbon"
        language = make_cell_div(text=lang)
        table_row.add(language)

    return lang_row

def make_spell_text(spell: Spell) -> str:
    return f"<b>DC:</b> {spell.dc} | <b>Save:</b> {spell.save_info} | <b>Casting Time:</b> {spell.casting_time} | <b>Target:</b> {spell.target} | <b>Range:</b> {spell.spell_range} | <b>Duration:</b> {spell.duration}<br>{spell.effect}"

def toggle_collapsible_content(self, msg):
    if 'hidden' in self.content.classes:
        self.content.remove_class('hidden')
    else:
        self.content.set_class('hidden')

def make_collapsible_comp(upper_container, button_name="", inner_text=""):
    content = jp.Div(inner_html=inner_text, classes='mt-4 border p-4 hidden')
    button = jp.Button(
        text=button_name,
        classes='bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded',
        click=toggle_collapsible_content
    )
    button.content = content
    upper_container.add(button)

    return content

def make_spells_box(char):
    spells_row = make_col_flex_div()
    table, table_body = make_table(["Spell", "Level"])

    spells_row.add(table)

    for spell in char.spells:
        table_row = jp.Tr()
        table_body.add(table_row)
        spell_cell = make_button_div()
        spell_cell.add(make_collapsible_comp(spell_cell, spell.name, make_spell_text(spell)))
        table_row.add(spell_cell)
        table_row.add(make_cell_div(text=spell.level))

    return spells_row

def make_spell_like_abilities_box(char):
    spell_like_abilities_row = make_col_flex_div()
    table, table_body = make_table(["Spell-like Abilities"])

    spell_like_abilities_row.add(table)

    table_row = jp.Tr()
    table_body.add(table_row)

    table_row.add(make_cell_div(text=char.spell_like_abilities))

    return spell_like_abilities_row

def make_skills_box(upper_container, char, rng):
    skills_row = make_col_flex_div()

    table, table_body = make_table(["Skill", "Modifier"])
    skills_row.add(table)

    for skill, modifier in char.skills.items():
        table_row = jp.Tr()
        table_body.add(table_row)
        skill_name = make_button_div()
        table_row.add(skill_name)
        roll_modal = make_roll_modal(upper_container, modifier=[modifier], rng=rng)
        button = make_roll_button(rng, roll_modal, text=skill, modifier=[modifier])
        skill_name.add(button)
        modifier_cell = make_cell_div(text=make_mod_text([modifier]))
        table_row.add(modifier_cell)

    return skills_row

def make_feats_box(char):
    feats_row = make_col_flex_div()
    table, table_body = make_table(["Feats"])

    feats_row.add(table)

    for feat in char.feats:
        table_row = jp.Tr()
        table_body.add(table_row)
        feat_cell = make_button_div()
        feat_cell.add(make_collapsible_comp(feat_cell, feat.feat_name, feat.feat_benefit))
        table_row.add(feat_cell)

    return feats_row

def make_proficiencies_box(char):
    prof_row = make_col_flex_div()
    table, table_body = make_table(["Weapon Proficiencies"])

    prof_row.add(table)

    table_row = jp.Tr()
    table_body.add(table_row)
    prof_cell = make_cell_div(text=char.weapon_proficiencies)
    table_row.add(prof_cell)

    return prof_row

def make_cmb_and_cmd_box(upper_container, char, rng):
    cm_row = make_col_flex_div(overflow=True)
    headers = [""]
    cmb = ["CMB"]
    cmd = ["CMD"]

    for cmb_name, value in char.cmb.items():
        table_header = cmb_name.split("_")[0]
        cmd_name = table_header + "_defense"
        headers.append(table_header)
        cmb.append(value)
        cmd.append(char.cmd[cmd_name])

    table, table_body = make_table(headers)
    cm_row.add(table)
    cmb_row = jp.Tr()
    cmd_row = jp.Tr()
    table_body.add(cmb_row, cmd_row)

    for i in range(len(headers)):
        cmd_cell = make_cell_div(text=cmd[i])
        cmd_row.add(cmd_cell)
        if i != 0:
            cmb_cell = make_button_div()
            cmb_row.add(cmb_cell)
            cmb_roll_modal = make_roll_modal(upper_container, modifier=[int(cmb[i])], rng=rng)
            cmb_button = make_roll_button(
                rng, cmb_roll_modal, text=make_mod_text([cmb[i]]), modifier=[int(cmb[i])])
            cmb_cell.add(cmb_button)
        else:
            cmb_cell = make_cell_div(text=cmb[i])
            cmb_row.add(cmb_cell)

    return cm_row

def make_large_row(upper_container, char, rng):
    main_row = make_row_flex_div()

    cm_box = make_cmb_and_cmd_box(upper_container, char, rng)

    left_col = make_one_third_col_div()
    abilities_box = make_abilities_box(upper_container, char, rng)
    weapons_box = make_weapons_box(upper_container, char, rng)
    left_col.add(abilities_box, weapons_box)
    if char.ranged_weapons:
        left_col.add(make_ranged_weapons_box(upper_container, char, rng))
    if char.spells:
        left_col.add(cm_box)
    if char.special_attacks:
        left_col.add(make_special_attacks_box(char))
    if char.special_abilities:
        left_col.add(make_special_qualities_box(char))
    left_col.add(make_feats_box(char))

    # saves, langs, proficiencies, spells
    middle_col = make_one_third_col_div()
    saves_box = make_saves_box(upper_container, char, rng)
    spell_like_abilities_box = make_spell_like_abilities_box(char)
    spells_box = make_spells_box(char)
    middle_col.add(saves_box)

    if not char.spells:
        middle_col.add(cm_box)

    if char.spell_like_abilities:
        middle_col.add(spell_like_abilities_box)

    if char.spells:
        middle_col.add(spells_box)

    right_col = make_one_third_col_div()
    right_col.add(make_skills_box(upper_container, char, rng), make_lang_box(char), make_proficiencies_box(char))

    main_row.add(left_col, middle_col, right_col)
    return main_row

def toggle_roll_modal(self, msg, rng, die=20, num_dice=1, modifier=0):
    if not self.roll_modal.show:
        rolls = roll_dice(rng, die_type=int(die), num_dice=int(num_dice), num_rolls=len(modifier))
        self.roll_modal.content.inner_html = make_roll_result_text(rolls, modifier)
    self.roll_modal.show = not self.roll_modal.show

def make_roll_modal(upper_container, rng, modifier=0, die=20, num_dice=1):
    modal_backdrop = jp.Div(
        classes="fixed w-full h-full top-0 left-0 flex items-center justify-center bg-black bg-opacity-50", show=False)
    upper_container.add(modal_backdrop)

    modal_content = jp.Div(classes="bg-white rounded shadow-lg w-1/3 p-8 m-4 relative")
    modal_backdrop.add(modal_content)
    modal_title = jp.H1(text="Roll", classes="text-xl font-bold mb-4")
    modal_content.add(modal_title)
    rolls = roll_dice(rng, die_type=int(die), num_dice=int(num_dice), num_rolls=len(modifier))
    modal_text = jp.P(text=make_roll_result_text(rolls, modifier), classes="mb-4")
    modal_content.add(modal_text)
    modal_backdrop.content = modal_text

    # Close button inside the modal
    close_button = jp.Button(
        text="Close", classes="bg-red-500 text-white px-4 py-2",
        click=toggle_roll_modal$(rng=rng, modifier=[modifier])
    )
    close_button.roll_modal = modal_backdrop
    modal_content.add(close_button)

    return modal_backdrop
